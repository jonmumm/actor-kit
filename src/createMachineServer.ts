import { compare } from "fast-json-patch";
import { SignJWT, jwtVerify } from "jose";
import type * as Party from "partykit/server";
import type {
  Actor,
  AnyStateMachine,
  EventFrom,
  SnapshotFrom,
  Subscription,
} from "xstate";
import { createActor, waitFor } from "xstate";
import { xstateMigrate } from "xstate-migrate";
import type { z } from "zod";
import { assert } from "./utils/misc";
import { EnvironmentSchema, RequestInfoSchema } from "./schemas";
import type {
  ActorKitStateMachine,
  Caller,
  CallerType,
  CloudFlareProps,
  CreateMachineProps,
  EventSchemas,
  ExtraContext,
  MachineServerOptions,
  OutputEvent,
  PublicSnapshotFrom,
} from "./types";
import { getCallerFromRequest } from "./utils/auth";
import { parseQueryParams } from "./utils/query-params";
import { json, notFound } from "./utils/response";

/**
 * Defines the types of callers that can interact with the actor system.
 * Each type represents a different source of events with varying levels of trust and permissions.
 * Note: SYSTEM events are handled internally by Actor Kit and are not defined by the user.
 */
const CallerTypes: Record<CallerType, CallerType> = {
  client: "client",
  system: "system", // Handled internally by Actor Kit
  service: "service",
};

/**
 * Caller Types Explanation:
 *
 * CLIENT:
 * - Represents events originating from end-users or client applications.
 * - Can be from browser-based clients or server-side clients acting on behalf of a user.
 * - Always associated with a user's stored token for authentication.
 * - Example: User actions, client-side updates, etc.
 *
 * SYSTEM:
 * - Represents internal events generated by the actor system itself.
 * - Not associated with any specific user or external service.
 * - Used for system-level operations, maintenance, or internal state management.
 * - Example: Cleanup tasks, periodic checks, internal state transitions.
 *
 * SERVICE:
 * - Represents events from trusted external services or internal microservices.
 * - Used for privileged operations that require a higher level of trust.
 * - Can perform actions like user authentication, data pushing, or system-wide updates.
 * - Example: Authentication service confirming a user's identity,
 *            data synchronization service updating actor state.
 */

const PERSISTED_SNAPSHOT_KEY = "persistedSnapshot";

/**
 * Loads a persisted snapshot from storage.
 * @param storage The storage interface to retrieve the snapshot from.
 * @returns The parsed snapshot or null if not found.
 */
const loadPersistedSnapshot = async (storage: Party.Storage) => {
  const persistentSnapshot = await storage.get(PERSISTED_SNAPSHOT_KEY);
  return persistentSnapshot ? JSON.parse(persistentSnapshot as string) : null;
};

/**
 * Applies any necessary migrations to the persisted snapshot.
 * @param machine The current state machine definition.
 * @param parsedSnapshot The snapshot to migrate.
 * @returns The migrated snapshot.
 */
const applyMigrations = (machine: AnyStateMachine, parsedSnapshot: any) => {
  const migrations = xstateMigrate.generateMigrations(machine, parsedSnapshot);
  if (migrations.length) {
    console.debug("Applying migrations: ", migrations);
  }
  return xstateMigrate.applyMigrations(parsedSnapshot, migrations);
};

/**
 * createMachineServer
 *
 * This function creates a server for managing actor-based state machines.
 * It provides a framework for handling different types of events from various sources
 * and manages the lifecycle of the actor.
 *
 * @param createMachine A function that creates the state machine. It receives:
 *   - props: An object of type CreateMachineProps, containing id, caller, and any additional properties
 *
 * @param eventSchemas An object containing Zod schemas for different event types:
 *   - client: Schema for events originating from end-users or client applications
 *   - service: Schema for events from trusted external services or internal microservices
 *   - output: Schema for output events that are broadcast to all connected clients
 *   Note: System events are defined internally by Actor Kit and should not be provided here.
 *
 * @param options An optional object containing additional options for the server:
 *   - persisted: A boolean indicating whether the actor's state should be persisted (default: false)
 *
 * @returns An ActorServer class that implements the Party.Server interface
 *
 * Usage Example:
 *
 * import { z } from 'zod';
 * import { createMachineServer } from './createMachineServer';
 *
 * // Define client event schema
 * const clientEventSchema = z.discriminatedUnion('type', [
 *   z.object({ type: z.literal('FORM_SUBMIT'), formData: z.record(z.string()) }),
 *   z.object({ type: z.literal('PAGE_LOADING') }),
 *   z.object({ type: z.literal('PAGE_LOADED') }),
 *   z.object({ type: z.literal('BUTTON_PRESS'), buttonId: z.string() }),
 *   z.object({ type: z.literal('CONNECT') }),
 * ]);
 *
 * // Define service event schema
 * const serviceEventSchema = z.discriminatedUnion('type', [
 *   z.object({ type: z.literal('AUTHENTICATE'), userId: z.string() }),
 *   z.object({ type: z.literal('DATA_SYNC'), data: z.record(z.unknown()) }),
 *   z.object({
 *     type: z.literal('PUSH_NOTIFICATION_RECEIVED'),
 *     notificationId: z.string(),
 *     message: z.string(),
 *     timestamp: z.number()
 *   }),
 * ]);
 *
 * // Define output event schema
 * const outputEventSchema = z.discriminatedUnion('type', [
 *   z.object({ type: z.literal('BROADCAST_MESSAGE'), message: z.string() }),
 *   z.object({ type: z.literal('UPDATE_STATUS'), status: z.string() }),
 * ]);
 *
 * // Define your machine creation function
 * const createMyMachine = (props: CreateMachineProps) => createMachine({
 *   id: `myMachine-${props.id}`,
 *   initial: 'idle',
 *   context: {
 *     caller: props.caller,
 *     notifications: [],
 *     // other context properties
 *   },
 *   states: {
 *     idle: {
 *       on: {
 *         CONNECT: 'connected',
 *         // other transitions
 *       }
 *     },
 *     connected: {
 *       on: {
 *         PUSH_NOTIFICATION_RECEIVED: {
 *           actions: assign({
 *             notifications: (context, event) => [...context.notifications, event]
 *           })
 *         }
 *       }
 *     },
 *     // other states
 *   }
 * });
 *
 * // Create the actor server
 * const MyActorServer = createMachineServer(
 *   createMyMachine,
 *   {
 *     client: clientEventSchema,
 *     service: serviceEventSchema,
 *     output: outputEventSchema,
 *   },
 *   { persisted: true } // enable persistence
 * );
 *
 * // PartyKit Configuration:
 * // Instead of using a partykit.config.ts file, create a partykit.json file in your project root:
 * //
 * // {
 * //   "$schema": "https://www.partykit.io/schema.json",
 * //   "name": "your-project-name",
 * //   "main": "app/lib/actor-kit/createMachineServer.ts",
 * //   "compatibilityDate": "2024-03-15",
 * //   "parties": {
 * //     "actor": "app/lib/actor-kit/createMachineServer.ts"
 * //   }
 * // }
 * //
 * // Adjust the "name", "main", and "compatibilityDate" fields as needed for your project.
 */

// todo next,

export const createMachineServer = <
  TMachine extends ActorKitStateMachine<
    z.infer<TEventSchemas["output"]> & { type: string }
  >,
  TEventSchemas extends EventSchemas
>(
  createMachine: (
    props: CreateMachineProps<
      z.infer<TEventSchemas["output"]> & { type: string }
    >
  ) => TMachine,
  eventSchemas: TEventSchemas,
  options?: MachineServerOptions
) => {
  const { persisted = false } = options || {};

  class ActorServer implements Party.Server {
    actor: Actor<TMachine> | undefined;
    lastSnapshotsByConnectionId: Map<string, PublicSnapshotFrom<TMachine>>;
    callersByConnectionId: Map<string, Caller>;
    subscrptionsByConnectionId: Map<string, Subscription>;
    lastPersistedSnapshot: SnapshotFrom<TMachine> | null = null;
    extraContext: ExtraContext | undefined;
    #connections: Map<string, Party.Connection> = new Map();

    constructor(public room: Party.Room) {
      this.lastSnapshotsByConnectionId = new Map();
      this.callersByConnectionId = new Map();
      this.subscrptionsByConnectionId = new Map();
    }

    setExtraContext(context: ExtraContext) {
      this.extraContext = context;
    }

    #createAndInitializeActor(
      props: Omit<
        CreateMachineProps<z.infer<TEventSchemas["output"]> & { type: string }>,
        "send"
      >
    ) {
      const send = (
        outputEvent: OutputEvent<
          z.infer<TEventSchemas["output"]> & { type: string }
        >
      ) => {
        const parseResult = eventSchemas.output.safeParse(outputEvent.event);
        if (parseResult.success) {
          this.#handleOutputEvent(outputEvent);
        } else {
          console.error("Invalid output event:", parseResult.error);
        }
      };

      const machine = createMachine({ ...props, send } as any);
      const actor = createActor(machine, { input: props } as any);
      if (persisted) {
        this.#setupStatePersistence(actor);
      }
      actor.start();
      return actor;
    }

    #setupStatePersistence(actor: Actor<TMachine>) {
      actor.subscribe((state) => {
        const fullSnapshot = actor.getSnapshot();
        if (fullSnapshot) {
          this.#persistSnapshot(fullSnapshot);
        }
      });
    }

    async #persistSnapshot(snapshot: SnapshotFrom<TMachine>) {
      try {
        if (
          !this.lastPersistedSnapshot ||
          compare(this.lastPersistedSnapshot, snapshot).length > 0
        ) {
          await this.room.storage.put(
            PERSISTED_SNAPSHOT_KEY,
            JSON.stringify(snapshot)
          );
          this.lastPersistedSnapshot = snapshot;
          console.log("Snapshot persisted successfully");
        } else {
          console.log("No changes in snapshot, skipping persistence");
        }
      } catch (error) {
        console.error("Error persisting snapshot:", error);
      }
    }

    #createPublicSnapshot(
      fullSnapshot: SnapshotFrom<TMachine>
    ): PublicSnapshotFrom<TMachine> {
      const snap = fullSnapshot as any;
      assert(snap.value, "expected value");
      assert(snap.context.public, "expected public key in context");
      return {
        public: snap.context.public,
        value: snap.value,
      };
    }

    async #initializePersistedActor() {
      const parsedSnapshot = await loadPersistedSnapshot(this.room.storage);
      if (!parsedSnapshot) return;

      const systemCaller: Caller = { id: this.room.id, type: "system" };
      const send = (
        outputEvent: OutputEvent<
          z.infer<TEventSchemas["output"]> & { type: string }
        >
      ) => {
        const parseResult = eventSchemas.output.safeParse(outputEvent.event);
        if (parseResult.success) {
          this.#handleOutputEvent(outputEvent);
        } else {
          console.error("Invalid output event:", parseResult.error);
        }
      };
      const machine = createMachine({
        id: this.room.id,
        caller: systemCaller,
        send,
      });
      const restoredSnapshot = applyMigrations(machine, parsedSnapshot);

      this.actor = createActor(machine, {
        snapshot: restoredSnapshot,
        input: { id: this.room.id, caller: systemCaller } as any,
      });
      this.actor.start();

      // Send RESUME event with system as the caller
      this.actor.send({
        type: "RESUME",
        caller: systemCaller,
      } as any);

      this.#setupStatePersistence(this.actor);
    }

    async onStart() {
      if (persisted) {
        await this.#initializePersistedActor();
      }
    }

    async #handleGetRequest(request: Party.Request, caller: Caller) {
      const params = parseQueryParams(request.url);
      const inputJsonString = params.get("input");
      assert(inputJsonString, "expected input object in query params");
      const inputJson = JSON.parse(inputJsonString);

      const actor = this.#ensureActorRunning({ caller, inputJson });
      const connectionId = crypto.randomUUID();
      this.callersByConnectionId.set(connectionId, caller);

      const { API_AUTH_SECRET } = EnvironmentSchema.parse(this.room.env);
      const token = await createConnectionToken(
        this.room.id,
        connectionId,
        caller.type,
        API_AUTH_SECRET
      );

      await waitFor(actor, (state) => {
        const anyState = state as SnapshotFrom<AnyStateMachine>;
        return anyState.matches({ Initialization: "Ready" });
      });

      const fullSnapshot = actor.getSnapshot();
      const publicSnapshot = this.#createPublicSnapshot(fullSnapshot);
      this.lastSnapshotsByConnectionId.set(connectionId, publicSnapshot);

      return json({
        connectionId,
        token,
        snapshot: publicSnapshot,
      });
    }

    async #handleEvent(
      event: any,
      caller: Caller,
      schema:
        | z.ZodDiscriminatedUnion<
            "type",
            [z.ZodObject<any>, ...z.ZodObject<any>[]]
          >
        | z.ZodObject<z.ZodRawShape & { type: z.ZodLiteral<string> }>,
      cf?: CloudFlareProps
    ) {
      const parsedEvent = schema.parse(event);
      this.#sendEventToActor(parsedEvent, caller, cf);
    }

    async #handlePostRequest(request: Party.Request, caller: Caller) {
      const jsonObj = await request.json();

      switch (caller.type) {
        case "client":
          await this.#handleEvent(
            jsonObj,
            caller,
            eventSchemas.client,
            request.cf
          );
          break;
        case "service":
          await this.#handleEvent(
            jsonObj,
            caller,
            eventSchemas.service,
            request.cf
          );
          break;
        default:
          throw new Error(
            `Unsupported caller type for POST request: ${caller.type}`
          );
      }

      return json({ status: "ok" });
    }

    async onRequest(request: Party.Request) {
      const { API_AUTH_SECRET } = EnvironmentSchema.parse(this.room.env);
      const caller = await getCallerFromRequest(
        request,
        this.room.name,
        this.room.id,
        this.callersByConnectionId,
        API_AUTH_SECRET
      );
      assert(caller, "expected caller to be set");

      if (request.method === "GET") {
        return this.#handleGetRequest(request, caller);
      } else if (request.method === "POST") {
        return this.#handlePostRequest(request, caller);
      }

      return notFound();
    }

    #ensureActorRunning({
      caller,
      inputJson,
    }: {
      caller: Caller;
      inputJson?: Record<string, unknown>;
    }) {
      if (!this.actor) {
        const props = {
          id: this.room.id,
          caller,
          ...inputJson,
        } as CreateMachineProps<
          z.infer<TEventSchemas["output"]> & { type: string }
        >;
        this.actor = this.#createAndInitializeActor(props);
      }
      return this.actor;
    }

    async onConnect(
      connection: Party.Connection,
      context: Party.ConnectionContext
    ) {
      const searchParams = new URLSearchParams(
        context.request.url.split("?")[1]
      );
      const token = searchParams.get("token");
      assert(token, "expected token when connecting to socket");

      try {
        const { API_AUTH_SECRET } = EnvironmentSchema.parse(this.room.env);
        const verified = await parseConnectionToken(token, API_AUTH_SECRET);
        const connectionId = verified.payload.jti;
        assert(connectionId, "expected connectionId from token");
        assert(
          connectionId === connection.id,
          "connectionId from token does not match connection id"
        );

        const caller: Caller = {
          id: verified.payload.sub as string,
          type: verified.payload.aud as "client" | "service",
        };

        this.callersByConnectionId.set(connection.id, caller);

        const actor = this.#ensureActorRunning({ caller });

        let lastSnapshot =
          this.lastSnapshotsByConnectionId.get(connection.id) || {};
        const sendSnapshot = (e?: any) => {
          assert(actor, "expected actor reference to exist");
          const fullSnapshot = actor.getSnapshot();
          const nextPublicSnapshot = this.#createPublicSnapshot(fullSnapshot);
          const operations = compare(lastSnapshot, nextPublicSnapshot);
          lastSnapshot = nextPublicSnapshot;
          if (operations.length) {
            connection.send(JSON.stringify({ operations }));
          }
          this.lastSnapshotsByConnectionId.set(
            connection.id,
            nextPublicSnapshot
          );
        };
        sendSnapshot();

        let requestInfo: z.infer<typeof RequestInfoSchema> | undefined;
        if (context.request.cf) {
          const result = RequestInfoSchema.safeParse(context.request.cf);
          if (result.success) {
            requestInfo = result.data;
          }
        }

        actor.send({
          type: "CONNECT",
          connectionId: connection.id,
          caller,
          requestInfo,
          parties: this.room.context.parties,
        } as any);

        const sub = actor.subscribe(sendSnapshot);
        this.subscrptionsByConnectionId.set(connection.id, sub);

        console.log(
          `Connected: ${connection.id}, Caller: ${JSON.stringify(caller)}`
        );
      } catch (error) {
        console.error("Error in onConnect:", error);
        connection.close();
      }
    }

    #handleOutputEvent(
      outputEvent: OutputEvent<
        z.infer<TEventSchemas["output"]> & { type: string }
      >
    ) {
      const { event, recipients } = outputEvent;
      const message = JSON.stringify({ type: "OUTPUT_EVENT", payload: event });

      if (recipients && recipients.length > 0) {
        recipients.forEach((recipient) => {
          const connection = this.#connections.get(recipient.id);
          if (connection) {
            connection.send(message);
          }
        });
      } else {
        // Broadcast to all connections if no specific recipients
        this.#connections.forEach((connection) => {
          connection.send(message);
        });
      }
    }

    #sendEventToActor(event: any, caller: Caller, cf?: CloudFlareProps) {
      assert(this.actor, "expected actor when sending event");
      const payload = {
        ...event,
        caller,
        cf,
      };
      this.actor.send(payload as EventFrom<TMachine>);
    }

    async onMessage(message: string, sender: Party.Connection) {
      try {
        const parsedMessage = JSON.parse(message);
        const caller = this.callersByConnectionId.get(sender.id);

        if (!caller) {
          throw new Error(`No caller found for connection ID: ${sender.id}`);
        }

        let schema: z.ZodSchema;
        if (caller.type === CallerTypes.client) {
          schema = eventSchemas.client;
        } else if (caller.type === CallerTypes.service) {
          schema = eventSchemas.service;
        } else {
          throw new Error(`Unsupported caller type: ${caller.type}`);
        }
        console.log("parsedMessage", parsedMessage);

        const event = schema.parse(parsedMessage);

        this.#ensureActorRunning({
          caller,
          inputJson: {},
        });

        const eventWithContext = {
          ...event,
          context: this.extraContext,
        };

        this.#sendEventToActor(eventWithContext, caller, event.cf);
      } catch (ex) {
        console.warn("Error processing message from client:", ex);
      }
    }

    async onClose(connection: Party.Connection) {
      const sub = this.subscrptionsByConnectionId.get(connection.id);
      if (sub) {
        sub.unsubscribe();
      }

      // Remove the connection
      this.#connections.delete(connection.id);
    }
  }

  return ActorServer satisfies Party.Worker;
};

const createConnectionToken = async (
  id: string,
  connectionId: string,
  callerType: string,
  secret: string
) => {
  let signJWT = new SignJWT({})
    .setProtectedHeader({ alg: "HS256" })
    .setSubject(id)
    .setAudience(callerType)
    .setJti(connectionId)
    .setIssuedAt()
    .setExpirationTime("1d");

  const token = await signJWT.sign(new TextEncoder().encode(secret));
  return token;
};

const parseConnectionToken = async (token: string, secret: string) => {
  const verified = await jwtVerify(token, new TextEncoder().encode(secret));
  assert(verified.payload.jti, "expected JTI on connectionToken");
  return verified;
};

/**
 * Example usage of createMachineServer:
 *
 * This example demonstrates how to create a simple chat room actor using createMachineServer.
 *
 * 1. Define your state machine:
 *
 * import { createMachine, assign } from 'xstate';
 *
 * const createChatMachine = (props: CreateMachineProps) => createMachine({
 *   id: `chat-${props.id}`,
 *   initial: 'active',
 *   context: {
 *     messages: [],
 *   },
 *   states: {
 *     active: {
 *       on: {
 *         SEND_MESSAGE: {
 *           actions: assign({
 *             messages: (context, event) => [...context.messages, event.message],
 *           }),
 *         },
 *       },
 *     },
 *   },
 * });
 *
 * 2. Define your event schemas:
 *
 * import { z } from 'zod';
 *
 * const clientEventSchema = z.discriminatedUnion('type', [
 *   z.object({ type: z.literal('SEND_MESSAGE'), message: z.string() }),
 *   z.object({ type: z.literal('PAGE_LOADING') }),
 *   z.object({ type: z.literal('PAGE_LOADED') }),
 *   z.object({ type: z.literal('BUTTON_PRESS'), buttonId: z.string() }),
 *   z.object({ type: z.literal('CONNECT') }),
 * ]);
 *
 * const serviceEventSchema = z.discriminatedUnion('type', [
 *   z.object({ type: z.literal('AUTHENTICATE'), userId: z.string() }),
 *   z.object({ type: z.literal('DATA_SYNC'), data: z.record(z.unknown()) }),
 * ]);
 *
 * const outputEventSchema = z.discriminatedUnion('type', [
 *   z.object({ type: z.literal('BROADCAST_MESSAGE'), message: z.string() }),
 *   z.object({ type: z.literal('UPDATE_STATUS'), status: z.string() }),
 * ]);
 *
 * 3. Create your actor server:
 *
 * const ChatActorServer = createMachineServer(
 *   createChatMachine,
 *   {
 *     client: clientEventSchema,
 *     service: serviceEventSchema,
 *     output: outputEventSchema,
 *   },
 *   { persisted: true } // Enable persistence
 * );
 *
 * 4. Use in PartyKit configuration:
 *
 * // In partykit.json
 * {
 *   "$schema": "https://www.partykit.io/schema.json",
 *   "name": "playitlive",
 *   "main": "app/lib/actor-kit/createMachineServer.ts",
 *   "compatibilityDate": "2024-02-10",
 *   "domain": "api.playitlive.tv",
 *   "parties": {
 *     "actor": "app/lib/actor-kit/createMachineServer.ts"
 *   }
 * }
 *
 * Now you have a chat room actor that can handle messages from clients,
 * system events, and service events, with persistence enabled.
 */
